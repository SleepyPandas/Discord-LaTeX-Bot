<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LaTeX Bot Monitor</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <main class="shell app">
    <section class="hero card">
      <p class="eyebrow">Discord LaTeX Bot</p>
      <div class="controls-row">
        <label for="range-select" class="label-control">Time Range</label>
        <select id="range-select" class="range-select">
          <option value="24h">24 Hours</option>
          <option value="7d">7 Days</option>
          <option value="30d">30 Days</option>
          <option value="90d" selected>90 Days</option>
        </select>
      </div>
      <p class="meta">Refresh interval: <code>30s</code></p>
    </section>

    <section class="cards-grid">
      <article class="metric card">
        <p class="label">Attempts <span class="window-pill" data-window-label>(90d)</span></p>
        <p class="value" id="attempts">0</p>
      </article>
      <article class="metric card">
        <p class="label">Successes <span class="window-pill" data-window-label>(90d)</span></p>
        <p class="value" id="successes">0</p>
      </article>
      <article class="metric card">
        <p class="label">Errors <span class="window-pill" data-window-label>(90d)</span></p>
        <p class="value" id="errors">0</p>
      </article>
      <article class="metric card">
        <p class="label">Error Rate <span class="window-pill" data-window-label>(90d)</span></p>
        <p class="value" id="error-rate">0.00%</p>
      </article>
    </section>

    <section class="grid">
      <article class="card panel">
        <div class="panel-head">
          <h2>By Source <span class="window-pill" id="source-window-pill">(90d)</span></h2>
          <span class="stamp" id="generated-at">Waiting for data</span>
        </div>
        <div id="source-breakdown" class="source-grid">
          <p class="muted">No events yet.</p>
        </div>
      </article>
      <article class="card panel chart-panel">
        <div class="panel-head">
          <h2>Requests, Successes, Errors</h2>
          <span class="stamp">X: Date, Y: Count</span>
        </div>
        <div class="chart-wrap">
          <canvas id="overview-chart"></canvas>
        </div>
      </article>
    </section>

    <section class="grid">
      <article class="card panel chart-panel">
        <div class="panel-head">
          <h2>Errors by Status</h2>
          <span class="stamp">X: Date, Y: Count</span>
        </div>
        <div class="chart-wrap">
          <canvas id="errors-chart"></canvas>
        </div>
      </article>
      <article class="card panel chart-panel">
        <div class="panel-head">
          <h2>Requests by Source</h2>
          <span class="stamp">X: Date, Y: Count</span>
        </div>
        <div class="chart-wrap">
          <canvas id="sources-chart"></canvas>
        </div>
      </article>
    </section>

    <section class="grid">
      <article class="card panel">
        <div class="panel-head">
          <h2>Recent Compile Events</h2>
          <span class="stamp">latest 50</span>
        </div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>Time (Toronto/New York)</th>
                <th>Source</th>
                <th>Status</th>
                <th>DPI</th>
                <th>User ID</th>
                <th>Error</th>
              </tr>
            </thead>
            <tbody id="events-body">
              <tr>
                <td colspan="6" class="empty">No event data loaded.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </article>
    </section>
  </main>

  <script src="/static/vendor/chart.umd.min.js"></script>
  <script>
    const WINDOW_KEYS = new Set(["24h", "7d", "30d", "90d"]);
    const attemptsEl = document.getElementById("attempts");
    const successesEl = document.getElementById("successes");
    const errorsEl = document.getElementById("errors");
    const errorRateEl = document.getElementById("error-rate");
    const generatedAtEl = document.getElementById("generated-at");
    const rangeSelectEl = document.getElementById("range-select");
    const sourceWindowPillEl = document.getElementById("source-window-pill");
    const windowLabelEls = document.querySelectorAll("[data-window-label]");
    const sourceBreakdownEl = document.getElementById("source-breakdown");
    const eventsBodyEl = document.getElementById("events-body");
    const overviewCanvas = document.getElementById("overview-chart");
    const errorsCanvas = document.getElementById("errors-chart");
    const sourcesCanvas = document.getElementById("sources-chart");
    const EVENT_TIME_ZONE = "America/Toronto";
    const eventTimeFormatter = new Intl.DateTimeFormat("en-CA", {
      timeZone: EVENT_TIME_ZONE,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false,
      hourCycle: "h23",
    });

    let overviewChart = null;
    let errorsChart = null;
    let sourcesChart = null;

    function asNumber(value) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : 0;
    }

    function text(value) {
      if (value === null || value === undefined || value === "") return "n/a";
      return String(value);
    }

    function escapeHtml(value) {
      return text(value)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll("\"", "&quot;")
        .replaceAll("'", "&#39;");
    }

    function badge(status) {
      const cls = String(status || "").toLowerCase();
      return `<span class="badge ${cls}">${escapeHtml(status)}</span>`;
    }

    function normalizeWindowKey(value) {
      const candidate = String(value || "").toLowerCase();
      return WINDOW_KEYS.has(candidate) ? candidate : "90d";
    }

    function setWindowPills(windowKey) {
      const label = `(${windowKey})`;
      for (const el of windowLabelEls) {
        el.textContent = label;
      }
      sourceWindowPillEl.textContent = label;
    }

    function formatAxisLabel(iso, bucket) {
      const date = new Date(iso);
      if (Number.isNaN(date.getTime())) {
        return iso;
      }
      if (bucket === "hour") {
        return date.toLocaleString([], {
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
          timeZone: "UTC",
        });
      }
      return date.toLocaleDateString([], {
        month: "short",
        day: "numeric",
        timeZone: "UTC",
      });
    }

    function chartOptions() {
      return {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: "index",
          intersect: false,
        },
        plugins: {
          legend: {
            labels: {
              color: "#c9d1d9",
              boxWidth: 12,
              usePointStyle: true,
            },
          },
        },
        scales: {
          x: {
            ticks: {
              color: "#8b949e",
              maxRotation: 0,
              autoSkip: true,
              maxTicksLimit: 10,
            },
            grid: {
              color: "#30363d",
            },
          },
          y: {
            beginAtZero: true,
            ticks: {
              color: "#8b949e",
              precision: 0,
            },
            grid: {
              color: "#30363d",
            },
          },
        },
      };
    }

    function sourceLineColor(index) {
      const hue = (index * 57) % 360;
      return `hsl(${hue}, 75%, 62%)`;
    }

    function sourceFillColor(index) {
      const hue = (index * 57) % 360;
      return `hsla(${hue}, 75%, 62%, 0.15)`;
    }

    function formatEventDateTime(value) {
      const parsed = new Date(value);
      if (Number.isNaN(parsed.getTime())) {
        return text(value);
      }

      const parts = eventTimeFormatter.formatToParts(parsed);
      const values = {};
      for (const part of parts) {
        if (part.type !== "literal") {
          values[part.type] = part.value;
        }
      }

      const year = values.year || "0000";
      const month = values.month || "00";
      const day = values.day || "00";
      const hour = values.hour || "00";
      const minute = values.minute || "00";
      const second = values.second || "00";
      return `${year} ${month} ${day} - ${hour}:${minute}:${second}`;
    }

    function upsertLineChart(currentChart, canvasEl, labels, datasets) {
      if (!currentChart) {
        return new Chart(canvasEl, {
          type: "line",
          data: { labels, datasets },
          options: chartOptions(),
        });
      }
      currentChart.data.labels = labels;
      currentChart.data.datasets = datasets;
      currentChart.update();
      return currentChart;
    }

    function renderOverviewChart(timeseries) {
      const bucket = text(timeseries?.window?.bucket);
      const labels = (timeseries.labels || []).map((item) => formatAxisLabel(item, bucket));
      const totals = timeseries.totals || {};
      overviewChart = upsertLineChart(overviewChart, overviewCanvas, labels, [
        {
          label: "Attempts",
          data: totals.attempts || [],
          borderColor: "#58a6ff",
          backgroundColor: "rgba(88, 166, 255, 0.2)",
          tension: 0.25,
        },
        {
          label: "Successes",
          data: totals.successes || [],
          borderColor: "#3fb950",
          backgroundColor: "rgba(63, 185, 80, 0.2)",
          tension: 0.25,
        },
        {
          label: "Errors",
          data: totals.errors || [],
          borderColor: "#f85149",
          backgroundColor: "rgba(248, 81, 73, 0.2)",
          tension: 0.25,
        },
      ]);
    }

    function renderErrorsChart(timeseries) {
      const bucket = text(timeseries?.window?.bucket);
      const labels = (timeseries.labels || []).map((item) => formatAxisLabel(item, bucket));
      const errorsByStatus = timeseries.errors_by_status || {};
      errorsChart = upsertLineChart(errorsChart, errorsCanvas, labels, [
        {
          label: "Timeout",
          data: errorsByStatus.timeout || [],
          borderColor: "#d29922",
          backgroundColor: "rgba(210, 153, 34, 0.2)",
          tension: 0.25,
        },
        {
          label: "Compile Error",
          data: errorsByStatus.compile_error || [],
          borderColor: "#f85149",
          backgroundColor: "rgba(248, 81, 73, 0.2)",
          tension: 0.25,
        },
        {
          label: "Internal Error",
          data: errorsByStatus.internal_error || [],
          borderColor: "#8b949e",
          backgroundColor: "rgba(139, 148, 158, 0.2)",
          tension: 0.25,
        },
      ]);
    }

    function renderSourcesChart(timeseries) {
      const bucket = text(timeseries?.window?.bucket);
      const labels = (timeseries.labels || []).map((item) => formatAxisLabel(item, bucket));
      const bySource = timeseries.by_source || {};
      const sourceEntries = Object.entries(bySource)
        .sort((left, right) =>
          right[1].reduce((sum, value) => sum + asNumber(value), 0) -
          left[1].reduce((sum, value) => sum + asNumber(value), 0)
        )
        .slice(0, 8);

      const datasets = sourceEntries.map(([name, values], index) => ({
        label: name,
        data: values || [],
        borderColor: sourceLineColor(index),
        backgroundColor: sourceFillColor(index),
        tension: 0.25,
      }));

      if (datasets.length === 0) {
        datasets.push({
          label: "No source data",
          data: labels.map(() => 0),
          borderColor: "#8b949e",
          backgroundColor: "rgba(139, 148, 158, 0.2)",
          tension: 0.25,
        });
      }

      sourcesChart = upsertLineChart(sourcesChart, sourcesCanvas, labels, datasets);
    }

    function renderSources(sources, windowKey) {
      const entries = Object.entries(sources || {});
      if (entries.length === 0) {
        sourceBreakdownEl.innerHTML = `<p class="muted">No events in the selected ${escapeHtml(windowKey)} window.</p>`;
        return;
      }

      sourceBreakdownEl.innerHTML = entries.map(([name, data]) => {
        const attempts = asNumber(data.attempts);
        const errors = asNumber(data.errors);
        const successes = asNumber(data.successes);
        const rate = attempts > 0 ? ((errors / attempts) * 100).toFixed(2) : "0.00";
        return `
          <div class="source-card">
            <p class="source-name">${escapeHtml(name)}</p>
            <p class="source-row">Attempts: <strong>${attempts}</strong></p>
            <p class="source-row">Successes: <strong>${successes}</strong></p>
            <p class="source-row">Errors: <strong>${errors}</strong></p>
            <p class="source-row">Error rate: <strong>${rate}%</strong></p>
          </div>
        `;
      }).join("");
    }

    function renderEvents(events) {
      if (!Array.isArray(events) || events.length === 0) {
        eventsBodyEl.innerHTML = '<tr><td colspan="6" class="empty">No events recorded yet.</td></tr>';
        return;
      }

      eventsBodyEl.innerHTML = events.map((event) => `
        <tr>
          <td>${escapeHtml(formatEventDateTime(event.created_at))}</td>
          <td>${escapeHtml(event.source)}</td>
          <td>${badge(event.status)}</td>
          <td>${escapeHtml(event.dpi)}</td>
          <td>${escapeHtml(event.user_id)}</td>
          <td class="error-cell">${escapeHtml(event.error_message)}</td>
        </tr>
      `).join("");
    }

    async function loadSummary(windowKey) {
      const resp = await fetch(`/api/summary?range=${encodeURIComponent(windowKey)}`, { cache: "no-store" });
      if (!resp.ok) throw new Error("summary request failed");
      return resp.json();
    }

    async function loadTimeseries(windowKey) {
      const resp = await fetch(`/api/timeseries?range=${encodeURIComponent(windowKey)}`, { cache: "no-store" });
      if (!resp.ok) throw new Error("timeseries request failed");
      return resp.json();
    }

    async function loadEvents() {
      const resp = await fetch("/api/events?limit=50", { cache: "no-store" });
      if (!resp.ok) throw new Error("events request failed");
      return resp.json();
    }

    function applySummary(data) {
      attemptsEl.textContent = asNumber(data.attempts);
      successesEl.textContent = asNumber(data.successes);
      errorsEl.textContent = asNumber(data.errors);
      errorRateEl.textContent = `${asNumber(data.error_rate_percent).toFixed(2)}%`;
      generatedAtEl.textContent = `Updated: ${text(data.generated_at)}`;
      const windowKey = normalizeWindowKey(data?.window?.key);
      setWindowPills(windowKey);
      rangeSelectEl.value = windowKey;
      renderSources(data.by_source, windowKey);
    }

    function applyTimeseries(data) {
      renderOverviewChart(data);
      renderErrorsChart(data);
      renderSourcesChart(data);
    }

    async function refresh() {
      const selectedRange = normalizeWindowKey(rangeSelectEl.value);
      try {
        const [summary, timeseries, events] = await Promise.all([
          loadSummary(selectedRange),
          loadTimeseries(selectedRange),
          loadEvents(),
        ]);
        applySummary(summary);
        applyTimeseries(timeseries);
        renderEvents(events.events || []);
      } catch (err) {
        generatedAtEl.textContent = "Failed to load data";
      }
    }

    if (typeof Chart === "undefined") {
      generatedAtEl.textContent = "Chart library failed to load";
    }

    rangeSelectEl.addEventListener("change", refresh);
    refresh();
    setInterval(refresh, 30000);
  </script>
</body>
</html>
